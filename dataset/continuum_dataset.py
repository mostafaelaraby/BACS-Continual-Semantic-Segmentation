from continuum.datasets import _ContinuumDataset
import numpy as np
from typing import Tuple
from continuum.tasks import TaskType

class PyTorchDataset(_ContinuumDataset):
    """Wrapper to support pytorch datasets in continuum format for continual learning.
    :param dataset_type: A Torchvision dataset
    """

    def __init__(
        self,
        data_path: str = "",
        dataset_type=None,
        dict_args: dict = {},
        transformation=None,
        train=True,
    ):
        """Initialize Continuum dataset

        Args:
            data_path (str, optional): path to the data saved used to save indices generated by continuum. Defaults to "".
            dataset_type (torch.dataset, optional): base class fo the dataset. Defaults to None.
            dict_args (dict, optional): Dictionary of arguments passed to the dataset. Defaults to {}.
            transformation (continuum.transforms): transformation used for that pytorch dataset
            train (bool, optional): flag to show if the dataset used in train/test mode. Defaults to True.
        """
        super().__init__(data_path=data_path, train=train)
        self.dataset_type = dataset_type
        self.dataset = self.dataset_type(**dict_args)
        self.transformation = transformation

    def __getitem__(self, indx):
        dataset = self.get_base_dataset()
        return dataset[indx]

    def __len__(self):
        dataset = self.get_base_dataset()
        targets = dataset.targets
        if hasattr(self.dataset, "base_dataset"):
            return len(targets)
        return len(self.dataset.indices)

    def get_base_dataset(self):
        if hasattr(self.dataset, "base_dataset"):
            return self.dataset.base_dataset
        return self.dataset.dataset.base_dataset

    def get_data(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        dataset = self.get_base_dataset()
        x, y = np.array(dataset.images), np.array(dataset.targets)
        if hasattr(self.dataset, "indices"):
            x = x[self.dataset.indices]
            y = y[self.dataset.indices]
        y = y.squeeze()
        return x, y, None

    @property
    def data_type(self) -> str:
        return TaskType.SEGMENTATION
